from openPM.Process.Path import Path
from openPM.ProcessMining import ProcessMining
import json


class Discovery(ProcessMining):
    """
    Know Bugs
    ---------
    + lifecyle transitions

    """
    def __init__(self, process):
        super().__init__(process)

    def get_direct_followers(self, activity_column: str, frequencies=False) -> set:
        """
        Finds all direct follower in an  process.

        :param activity_column: The activity attribute that is used for the process visualization
        :param frequencies: If frquencies of the occuriences should be calculated as well.
        :return: set of path objects
        """

        def clean_attributes(attrs):
            return_list = attrs[:]
            for attr in attrs:
                key = attr.key
                if key != activity_column:
                    return_list.remove(attr)
            return return_list

        path_set = set()
        path_list = []
        for index, instance in self.process.process.iterrows():
            events = instance["event_attributes"]
            for i, event in enumerate(events):
                attributes_i = clean_attributes(event.attributes)
                if i + 1 < len(events):
                    attributes_j = clean_attributes(events[i + 1].attributes)
                    path = Path(attributes_i[0].value, attributes_j[0].value)
                    if frequencies:
                        if path in path_set:
                            #path_list = list(path_set)
                            for j, old_path in enumerate(path_list):
                                if j != len(path_list)-1:
                                    if path == old_path:
                                        x = path_list[j].frequency
                                        path.increase_absolute_frequency(int(x))
                                        path_set.remove(old_path)
                                        path_set.add(path)
                                        path_list.pop(j)
                                        path_list.append(path)
                                        # path_list = path_list if j == 0 else path_list.pop(len(path_list))
                        else:
                            path_set.add(path)
                            path_list.append(path)
                    else:
                        path_set.add(path)
        return path_set

    @staticmethod
    def get_causal_dependencies(path_set: set):
        return_set = set(path_set)
        non_causal_dependencies = []
        for path in path_set:
            source = path.source
            sink = path.sink
            check_path = Path(sink, source)
            if check_path in path_set:
                non_causal_dependencies.append(check_path)

        for path in non_causal_dependencies:
            return_set.remove(path)

        return return_set

    # TODO-fixme this method is not working!
    '''
    @staticmethod
    def get_non_causal_dependencies(path_set):
        non_causal_dependencies = []
        for path in path_set:
            source = path.get_source()
            sink = path.get_sink()
            check_path = Path(sink, source)
            if check_path in path_set:
                non_causal_dependencies.append(check_path)
        return non_causal_dependencies
    '''

    @staticmethod
    # TODO - fixme
    def calculate_dependency_measures(path_set: set) -> set:
        path_list = list(path_set)
        for path in path_list:
            source_1 = path.source
            sink_1 = path.sink
            for item in path_list:
                source_2 = item.source
                sink_2 = item.sink
                if source_1 == sink_2 and sink_1 == source_2:
                    freq_1 = path.frequency
                    freq_2 = item.frequency
                    dependency = (freq_1-freq_2)/(freq_2+freq_1+1)
                    path.set_dependency_measure(dependency)
        return set(path_list)



    def to_json(self, path_set: set, include_events: bool, output_path=None) -> str:
        """
        This method returns a json str with following structure:

        :param path_set:
        :param include_events:
        :param output_path:
        :return: json string
        """
        events = []
        start_events = []
        end_events = []
        paths = []

        # start & end events

        for start in self.process.get_start_activities("concept:name"):
            start_events.append({"name": start})

        for end in self.process.get_end_activities("concept:name"):
            end_events.append({"name": end})

        # nodes
        if include_events:
            activity_set = set()
            for path in path_set:
                activity_set.add(path.source)
                activity_set.add(path.sink)
            for event in activity_set:
                events.append({"name": event})

        # links
        for path in path_set:
            dict = {"source": path.source, "target": path.sink, "value": path.frequency}
            paths.append(dict)

        response_json = {}
        response_json["startNodes"] = start_events
        response_json["endNodes"] = end_events
        if include_events:
            response_json["nodes"] = events
        response_json["links"] = paths

        if output_path is None:
            return json.dumps(response_json, indent=2)
        else:
            with open(output_path, 'w') as outfile:
                json.dump(response_json, outfile, indent=2,
                          ensure_ascii=False)
            return ""

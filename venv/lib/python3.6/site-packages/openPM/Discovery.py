from openPM.Process.Path import Path
from openPM.ProcessMining import ProcessMining
import json


class Discovery(ProcessMining):
    def __init__(self, process):
        super().__init__(process)

    # TODO what happens with lifecycle with start and complete for one event??
    # TODO-fixme this sucks as fuck. How do i get the frequencies? Without losing so much performance?
    def get_direct_followers(self, activity_column: str, frequencies=False):
        """

        :param activity_column: The activity attribute that is used for the process visualization
        :param frequencies:
        :return:
        """

        def clean_attributes(attrs):
            return_list = attrs[:]
            for attr in attrs:
                key = attr.get_key()
                if key != activity_column:
                    return_list.remove(attr)
            return return_list

        path_set = set()
        path_list = []
        for index, instance in self.process.get_process().iterrows():
            events = instance["event_attributes"]
            for i, event in enumerate(events):
                attributes_i = clean_attributes(event.get_attributes())
                if i + 1 < len(events):
                    attributes_j = clean_attributes(events[i + 1].get_attributes())
                    path = Path(attributes_i[0].get_value(), attributes_j[0].get_value())
                    if frequencies:
                        if path in path_set:
                            #path_list = list(path_set)
                            for j, old_path in enumerate(path_list):
                                if j != len(path_list)-1:
                                    if path == old_path:
                                        x = path_list[j].get_frequency()
                                        path.increase_absolute_frequency(int(x))
                                        path_set.remove(old_path)
                                        path_set.add(path)
                                        path_list.pop(j)
                                        path_list.append(path)
                                        # path_list = path_list if j == 0 else path_list.pop(len(path_list))
                        else:
                            path_set.add(path)
                            path_list.append(path)
                    else:
                        path_set.add(path)
        return path_set

    @staticmethod
    def get_causal_dependencies(path_set):
        return_set = set(path_set)
        non_causal_dependencies = []
        for path in path_set:
            source = path.get_source()
            sink = path.get_sink()
            check_path = Path(sink, source)
            if check_path in path_set:
                non_causal_dependencies.append(check_path)

        for path in non_causal_dependencies:
            return_set.remove(path)

        return return_set

    # TODO-fixme this method is not working!
    @staticmethod
    def get_non_causal_dependencies(path_set):
        non_causal_dependencies = []
        for path in path_set:
            source = path.get_source()
            sink = path.get_sink()
            check_path = Path(sink, source)
            if check_path in path_set:
                non_causal_dependencies.append(check_path)
        return non_causal_dependencies

    @staticmethod
    # TODO - fixme
    def calculate_dependency_measures(path_set: set) -> set:
        path_list = list(path_set)
        for path in path_list:
            source_1 = path.get_source()
            sink_1 = path.get_sink()
            for item in path_list:
                source_2 = item.get_source()
                sink_2 = item.get_sink()
                if source_1 == sink_2 and sink_1 == source_2:
                    freq_1 = path.get_frequency()
                    freq_2 = item.get_frequency()
                    dependency = (freq_1-freq_2)/(freq_2+freq_1+1)
                    path.set_dependency_measure(dependency)
        return set(path_list)



    def to_json(self, path_set: set, include_events: bool, output_path=None) -> str:
        events = []
        start_events = []
        end_events = []
        paths = []

        # start & end events

        for start in self.process.get_start_activities("concept:name"):
            start_events.append({"name": start})

        for end in self.process.get_end_activities("concept:name"):
            end_events.append({"name": end})

        # nodes
        if include_events:
            activity_set = set()
            for path in path_set:
                activity_set.add(path.get_source())
                activity_set.add(path.get_sink())
            for event in activity_set:
                events.append({"name": event})

        # links
        for path in path_set:
            dict = {"source": path.get_source(), "target": path.get_sink(), "value": path.get_frequency()}
            paths.append(dict)

        response_json = {}
        response_json["startNodes"] = start_events
        response_json["endNodes"] = end_events
        if include_events:
            response_json["nodes"] = events
        response_json["links"] = paths

        if output_path is None:
            return json.dumps(response_json, indent=2)
        else:
            with open(output_path, 'w') as outfile:
                json.dump(response_json, outfile, indent=2,
                          ensure_ascii=False)
            return ""
